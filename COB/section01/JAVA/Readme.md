# Java 문법 기초 이론



1. 변수 타입 -> 참조형(스택에 힙 메모리 주소 저장하는 컨테이너 -> 힙 영역 사용으로 읽기,쓰기 가능) / 기본형(원시타입)(스택에 constant pool(위치는 jvm에 따라 다름 java 8 기준 metaspace)의 리터럴 주소를 저장하는 컨테이너 -> null 불가능, 쓰기 불가능, 산술연산 가능)

3. jvm의 최소 메모리 엑세스 크기 = 1 byte
4. 자바는 키워드, 숫자로 시작하는 변수명을 가질수 없다. 
5. 리터럴 -> metaspace(java8 기준) 내부의 constant pool에 값 저장. not EMPTY, 고정된 크기, 고정된 값, 고정된 해석, 상수, 기본형 타입들 + null 리터럴(string 에만
6. 숫자 리터럴에는 진수 표현을 위해 접두사(binary 0b, octal 0, hex 0x) 사용, 단순한 숫자 그룹 구분을 위해 _ 사용(22_2==2_22, _222 or 222_ 불가능)
7. 이스케이프 시퀀스(\) -> 리터럴에 허용되지 않는 문자코드
8. 정수형 -> byte(1) 이진수 표현용 < short(2) < int(4) < long(8) (주의: Long은 참조형 래퍼 클래스임. 오타 주의 - 메모리 누수 발생) int 오버플로우 -> long 형변환 사용(끝에 L 붙이기)
9. 실수형 -> float(4) f를 붙여서 사용 <double(8) 기본 실수형 타입. 부동 소수점의 문제로 표현 못하는 실수 존재(특히 나누기 연산에서 INFINITY, NaN 리턴 처리 필요), 정수리터럴에 지수표현(E e) 사용시 실수 타입의 변수에 저장. 표현 범위가 매우 넓으므로 큰 숫자가 예상될때 사용.
10. 논리타입 -> boolean(1) 자바에서는 명확하게 logical 값과 int 값을  구분한다. 삼항 연산자를 이용하여 int 리턴을 할수 있다.
11. 문자타입 -> char(2) 유니코드 기반. utf-8 인코딩을 사용하여 아스키코드와 호환성이 있다. int로 암시적 업캐스팅을 통해 아스키코드 값을 확인 가능(아스키 값 2 = int 2 + 48). 
12. copy 수행시(할당) -> 기본 자료형 -> deep copy. 값의 복사 발생. 같은 값, 다른 메모리 주소. 원본 보호
13.          -> 참조 자료형 -> shallow copy. 주소의 복사 발생. 같은 참조 주소. 원본 변경시 관련된 모든 객체 호출 값 변화.
14. 파라미터로 전달시 -> 주소 "값" 전달. 메소드 내부에서 전달 받은 주소 값을 참조하여 메소드 수행. call by (object address) value. 결론적으로 call by reference의 개념을 만족한다.
-------------------------------------------------------------------------------------               
16. 문자열 String -> 이뮤터블 객체. 문자열 리터럴의 주소를 가지고 있다. new String으로 생성 가능. 리터럴이 아닌 객체 생성으로 메모리 영역(metaspace vs heap)이 다르다.

18. 문자열 처리는 별도로 정리
19. StringBuilder -> non 이뮤터블 객체. 성능상의 이점을 가지고 있다. 별도 정리
20. 상수 final -> 주의: 기본형 타입에는 상수로 처리가능. 하지만 참조형 변수의 경우 가리키는 객체는 final의 범위를 벗어나므로 값 변경 가능.
21. 클래스 final -> 확장(상속) 금지. 하지만 클래스까지만 final 영역이므로 내부의 필드는 수정 가능.
22. 메소드 final -> 오버라이딩 금지.
-----------------------------------------------------------------------------------------
24. 원시타입 형변환 -> 크기, 정밀도(정수<실수). 표현범위 초과시 한바퀴 돌아버리거나 에러 발생. 큰 데이터를 작은 타입 변수에 대입시 다운캐스팅 필수

26. 연산자 -> + - * 데이터 크기만 주의. 
27. 나누기 연산시 어느 하나라도 실수형이어야 소수 버림 발생 X, 정수를 0 나누기 -> 에러, 실수를 0으로 나누기 -> Infinity 리턴 -> Double.isinfinite(연산결과) 이용
28. 모듈러 연산은 정수간 연산 추천, 정수를 0 모듈러 -> 에러, 실수를 0 모듈러 -> NaN(not a number) 리턴 -> Double.isNaN(연산결과) 이용
29. 비교 연산자 -> 원시 타입간에 ==, 참조형 타입간에 .equals() 공통메서드 사용.
30. 조건 연산자 -> 조건식 ? 참 값 : 거짓 값
------------------------------------------------------------------------------------------
32. 콘솔 출력 -> System.out.print(내용). printf -> %b 불리언, %d 10진수 %o octal %x hex %n line separator System.lineSeparator() return lineSeparator(문자열로 사용)

34. 콘솔 입력 -> Scanner 객체 이용. Scanner sc = new Scanner(System.in) -> sc.next() 계열 함수 sc.nextLine() 함수
35. next() 계열 함수 -> 공백(개행,띄어쓰기,탭 등 모두) 이전 까지 버퍼에서 잘라온다. -> 버퍼에 여전히 내용 남아있음. next()를 여러번 사용하여 모두 불러오기 가능. 마지막 공백이 여전히 남는다.
36. nextLine() -> 공백을 포함하여 공백까지의 입력을 버퍼에서 잘라온다. charAt(length()-1)에 공백문자가 남아있음을 확인할 수 있다. 이전에 남은 버퍼의 공백을 읽어오는 경우가 많으므로 확인이 필요하다.
---------------------------------------------------------------------------------------
38. if(){} else if(){} else{} -> 부정적 상황(종료 조건 만족 확인)을 체크하여 return(종료 수행)으로 분기 나누기. -> 중첩 if를 선형적 if로 표현 가능. 예외 처리 방식으로 if 조건문 사용하기

40. switch case 문 -> break; 가 없으면 fall through 로 인해 여러 조건이 한번에 실행된다. -> 개선된 switch 이용
41. 조건변수에 string 사용이 가능해졌다.(java 7) 주의 : equals() 기반으로 구현되었으므로 null string 사용시 에러 발생. 별도의 null처리 필요(switch 내부에서 처리 불가능).
42. 개선된 switch문(java 14 이후) -> case 값,값,값 -> 수행문; default -> 수행문;
43. 개선된 switch문 2 -> 변수에 바로 대입 가능 -> 타입 변수 = switch(조건변수){ case 값 -> {리턴값}; default -> 기본값;} -> 변수가 리턴값으로 초기화 된다.
44. 조건변수에 열거형(enum) 사용으로 효율적으로 작성가능. 주의: 조건변수 값을 표현시 열거형이름을 제외한 값만 사용하여 케이스 체크.
45. 컴파일러는 조건변수의 모든 값을 논리적으로 확인하지 않는다.(특히 조건변수에 연산문 사용시) 그러므로 default로 예외사항을 항상 처리해야만 한다.
46. 쓰레드 관련 메소드 yield 사용 가능
--------------------------------------------------------------------------------------------------
47. for(인덱스 초기화; 조건식; 증감식) -> 중첩시 반복되는 덩어리를 파악하기. 가장 큰 반복 단위가 첫 for문

49. 개선된 for문(for each) -> 이터레이터 이용가능  -> for(타입 변수 : 이터레이터 변수(배열 등)) -> 이터레이터 변수를 순회하면서 변수에 대입.
50. while(조건문 true 확인) -> 내부에 종료 조건, 증감식 사용
51. continue;, break;
52. do{한번 무조건 수행, 조건참일때 반복 수행} while(조건식); 주의 : 세미콜론!
-------------------------------------------------------------------------------------------------------
53. 배열 선언 int[] arr

55. 배열 생성 new int[length] new int[]{요소} 자동 길이 할당.
56. 2차원 배열 [행 row 개수][열 col 개수] -> { {row 0    } {row 1      }  }
57. 가변 배열 -> 길이 미지정 -> 미지정 배열에 new int[length] 할당으로 초기화. -> 2차원 이상에서 사용 new int[10][]
------------------------------------------------------------------------------------------------
59. 자주 사용되는 라이브러리 Math Integer Double Char String Arrays
